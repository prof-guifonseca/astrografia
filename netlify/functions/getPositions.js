require('dotenv').config();
const { OpenAI } = require('openai');
const fetch = require('node-fetch');

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

async function obterCoordenadas(local) {
  const key = process.env.OPENCAGE_API_KEY;
  const url = `https://api.opencagedata.com/geocode/v1/json?q=${encodeURIComponent(local)}&key=${key}&language=pt&no_annotations=1&limit=1`;
  const res = await fetch(url);
  const json = await res.json();
  const geo = json?.results?.[0]?.geometry;
  if (!geo) throw new Error('Coordenadas n√£o encontradas');
  return geo;
}

function formatarPrompt({ birthDate, birthTime, birthPlace, lat, lng }) {
  return `
Voc√™ √© um astr√≥logo profissional com acesso a efem√©rides reais. Calcule e retorne as posi√ß√µes dos seguintes astros:

- Sol, Lua, Merc√∫rio, V√™nus, Marte, J√∫piter, Saturno, Urano, Netuno
- Ascendente (com base em latitude, longitude e hora local)

Cada planeta deve conter:
‚Ä¢ name (exato, com inicial mai√∫scula)
‚Ä¢ sign (nome completo do signo)
‚Ä¢ degree (grau decimal entre 0.0 e 29.99)
‚Ä¢ icon (s√≠mbolo unicode oficial do planeta)

O Ascendente deve conter:
‚Ä¢ sign
‚Ä¢ degree (grau decimal)

Use astrologia tropical.

‚ö†Ô∏è Instru√ß√µes obrigat√≥rias:
‚Ä¢ Todos os graus devem ser n√∫meros v√°lidos (ex: 12.7)
‚Ä¢ Lua e Ascendente devem refletir efem√©rides reais, com precis√£o pr√≥xima ao AstroSeek ou Personare
‚Ä¢ Retorne **apenas o JSON** entre crases, sem explica√ß√µes antes ou depois

Formato de sa√≠da:
\`\`\`json
{
  "planets": [
    { "name": "Sol", "sign": "Capric√≥rnio", "degree": 10.2, "icon": "‚òÄÔ∏è" },
    { "name": "Lua", "sign": "Touro", "degree": 18.4, "icon": "üåô" }
    ...
  ],
  "ascendant": {
    "sign": "Aqu√°rio",
    "degree": 5.1
  }
}
\`\`\`

Informa√ß√µes da pessoa:
- Data: ${birthDate}
- Hora: ${birthTime}
- Local: ${birthPlace}
- Latitude: ${lat}
- Longitude: ${lng}
`.trim();
}

exports.handler = async function (event) {
  try {
    const { birthDate, birthTime, birthPlace } = JSON.parse(event.body || '{}');

    if (!birthDate || !birthTime || !birthPlace) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Data, hora e local obrigat√≥rios.' })
      };
    }

    const { lat, lng } = await obterCoordenadas(birthPlace);
    const prompt = formatarPrompt({ birthDate, birthTime, birthPlace, lat, lng });

    const completion = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content: 'Voc√™ √© um astr√≥logo preciso, confi√°vel e sens√≠vel, com conhecimento t√©cnico e habilidade para gerar resultados compat√≠veis com efem√©rides reais.'
        },
        { role: 'user', content: prompt }
      ],
      temperature: 0.2,
      max_tokens: 800
    });

    const raw = completion.choices?.[0]?.message?.content || '';
    const match = raw.match(/```json([\s\S]*?)```/);
    const jsonStr = match ? match[1].trim() : raw.trim();

    let data;
    try {
      data = JSON.parse(jsonStr);
    } catch (err) {
      console.error('[Astrografia] JSON inv√°lido retornado pelo modelo:', jsonStr);
      return {
        statusCode: 500,
        body: JSON.stringify({
          error: 'O modelo retornou um JSON inv√°lido.',
          rawResponse: raw
        })
      };
    }

    return {
      statusCode: 200,
      body: JSON.stringify({
        ...data,
        location: { lat, lng },
        rawResponse: raw
      })
    };

  } catch (err) {
    console.error('[Astrografia] Erro com GPT na obten√ß√£o do mapa:', err);
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Erro interno na gera√ß√£o astrol√≥gica com GPT.' })
    };
  }
};
